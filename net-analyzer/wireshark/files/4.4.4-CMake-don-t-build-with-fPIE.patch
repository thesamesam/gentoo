From d49a220042f7f3f42d79a9eace9a75c848cf2ec2 Mon Sep 17 00:00:00 2001
Message-ID: <d49a220042f7f3f42d79a9eace9a75c848cf2ec2.1744920255.git.sam@gentoo.org>
From: Sam James <sam@gentoo.org>
Date: Thu, 17 Apr 2025 19:57:46 +0100
Subject: [PATCH] CMake: don't build with -fPIE
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Qt's qcompilerdetection.h currently checks for whether -fPIE is being used
along with QT_USE_PROTECTED_VISIBILITY ("reduce relocations", which Qt
automatically uses if supported). It bails out if -fPIE is used, as -fPIC
is required instead.

If LTO is used, when one does something like:
(1) g++ -c -flto -fPIC qtlto.cc
(2) g++     -pie -fPIE qtlto.o -o qtlto

At point (1), the Qt check in the headers fires, and everything is fine,
because we're indeed using -fPIC, and GCC doesn't automatically add -fPIE
when built with --enable-default-pie if -fPIC is present on the command line.

GCC may apply optimisations at this point given Qt is using -mno-direct-extern-access
and it was built with -fPIC not -fPIE.

Later, at point (2), -fPIE is passed. This happens in Wireshark because
`CMAKE_POSITION_INDEPENDENT_CODE` gets set in CMakeLists.txt. With LTO,
there's no opportunity for the Qt sanity check in headers to fire again,
as everything is already long-preprocessed and GCC will have applied some
optimisations already assuming the -fPIC code model in (1). But as slyfox
says at https://bugs.gentoo.org/754021#c12, GCC merges -fPIC -fPIE to -fPIE
at LTO-time (-fPIC coming from the earlier LTO object in (1), and -fPIE
was just-passed on the command line).

qtlto (or Wireshark) then crashes. For Wireshark, this looks like:
```
 #0  0x00007ff40e529cf0 in QScopedPointer<QObjectData, QScopedPointerDeleter<QObjectData> >::get (this=<optimized out>)
     at /usr/src/debug/dev-qt/qtbase-6.8.3/qtbase-everywhere-src-6.8.3/src/corelib/tools/qscopedpointer.h:112
 #1  qGetPtrHelper<QScopedPointer<QObjectData, QScopedPointerDeleter<QObjectData> > > (ptr=<optimized out>)
     at /usr/src/debug/dev-qt/qtbase-6.8.3/qtbase-everywhere-src-6.8.3/src/corelib/global/qtclasshelpermacros.h:128
 #2  QObject::d_func (this=<optimized out>) at /usr/src/debug/dev-qt/qtbase-6.8.3/qtbase-everywhere-src-6.8.3/src/corelib/kernel/qobject.h:108
 #3  QObjectPrivate::get (o=<optimized out>) at /usr/src/debug/dev-qt/qtbase-6.8.3/qtbase-everywhere-src-6.8.3/src/corelib/kernel/qobject_p.h:150
 #4  doActivate<false> (sender=0x0, signal_index=9, argv=argv@entry=0x7ffe59a73c30) at /usr/src/debug/dev-qt/qtbase-6.8.3/qtbase-everywhere-src-6.8.3/src/corelib/kernel/qobject.cpp:4003
 #5  0x00007ff40e4d2809 in QMetaObject::activate
     (sender=<optimized out>, m=m@entry=0x7ff40f44f6c0 <QGuiApplication::staticMetaObject>, local_signal_index=local_signal_index@entry=1, argv=argv@entry=0x7ffe59a73c30)
     at /usr/src/debug/dev-qt/qtbase-6.8.3/qtbase-everywhere-src-6.8.3/src/corelib/kernel/qobject.cpp:4183
 #6  0x00007ff40ead5676 in QGuiApplication::screenAdded (this=<optimized out>, _t1=<optimized out>)
[...]
```

Simply dropping CMAKE_POSITION_INDEPENDENT_CODE works fine for us
because in Gentoo, both GCC and Clang are configured to default to PIE
(but in such a way that it doesn't override what is specified on the cmdline).

Note also that later on in Wireshark's CMakeLists.txt, they pass -pie
anyway (which is fine, because -pie doesn't affect the *code model*) regardless
of CMAKE_POSITION_INDEPENDENT_CODE. -fPIC gets passed in to various places
before because Qt's CMake config files have INTERFACE_COMPILE_OPTIONS w/ -fPIC.

The removed CMAKE_POSITION_INDEPENDENT_CODE will per definition only apply
to executables and static libraries which Wireshark uses *for* executable,
so it's safe to drop. If the removal of CMAKE_POSITION_INDEPENDENT_CODE affected
any static libraries *installed* by CMake where -fPIC was no longer passed for
those, we would have a problem.

There are some questions:
(3) Why doesn't this happen with Clang, given that Clang has -fno-direct-access-external-data
    (equivalent to GCC's -mno-direct-extern-access), even when Qt is built
    with bfd (not lld)?

    The answer seems to be that Clang doesn't implement the optimisation
    yet to avoid copy-relocations where possible. GCC implemented that in
    5.x in r5-5573-g77ad54d911dd7c.

(4) Why doesn't this (seem to) happen in other distributions?

    nextcloud-client suffers from the same issue analysed here, see
    https://bugs.gentoo.org/933110. The upstream bug at https://github.com/nextcloud/desktop/issues/2790
    was reported by a Debian developer (cgzones), so it's a reasonable assumption
    that it can happen on Debian.

    Debian is one of few distributions (we're another) to use --enable-default-pie
    in GCC rather than just passing it to all package builds in the package manager.

    Debian also stopped building Wireshark with LTO because of a bug in Wireshark
    itself (https://bugs.gentoo.org/941890), so I guess they disabled LTO
    and didn't notice this crash.

    (This is enough for me to be more confident in my analysis, anyway.)

(5) Could Qt communicate this somehow automatically?

    I think it might be able to if statically linking Qt and Qt was built
    with LTO.

    Otherwise, I think the only option would be an ELF .note. pkg-config
    could maybe work but you can't assume all Qt consumers use that...

    See the discussion around <https://bugreports.qt.io/browse/QTBUG-45755?focusedId=282483&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-282483>:
    > Thiago Macieira added a comment - 22 May '15 17:11
    > There aren't that many autoconf-based Qt5 builds and we've never exported the flag anyway.

    (It might be worth bringing this .note idea up to Thiago and/or H.J. but
    I'm not sure yet if it'll work.)

(6) Could we just disable "reduce relocations" in Qt itself, given that
    the workaround here will need to be applied in various Qt consumers?

    This would significantly impact startup times of applications using Qt
    and there don't seem to be too many applications doing this (only 2
    known so far in Gentoo: Wireshark and nextcloud-client).

Thanks to Arusekk for producing a minimal example and reporting it upstream
to Wireshark, thanks to slyfox for analysing the interaction with LTO, thanks
to Holger for the discussion around it and testing, and thanks to Eli for
reviewing the commit message.

Bug: https://bugs.gentoo.org/754021
Bug: https://bugs.gentoo.org/933110
Bug: https://bugs.gentoo.org/941890
Bug: https://gitlab.com/wireshark/wireshark/-/issues/17040
Bug: https://bugreports.qt.io/browse/QTBUG-45755
Bug: https://bugreports.qt.io/browse/QTBUG-47942
Bug: https://gcc.gnu.org/PR65248
Bug: https://gcc.gnu.org/PR65886
Thanks-to: Arusekk <arek_koz@o2.pl>
Thanks-to: Sergei Trofimovich <slyfox@gentoo.org>
Thanks-to: Holger Hoffst√§tte <holger@applied-asynchrony.com>
Thanks-to: Eli Schwartz <eschwartz@gentoo.org>
---
 CMakeLists.txt | 6 ------
 1 file changed, 6 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index d82a718bf6..7bc80392c8 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -520,12 +520,6 @@ if(CMAKE_MAKE_PROGRAM MATCHES "ninja" AND OSS_FUZZ)
 	message(STATUS "Ninja job pool size: ${parallel_link_jobs}")
 endif()
 
-# Always enable position-independent code when compiling, even for
-# executables, so you can build position-independent executables.
-# -pie is added below for non-MSVC, but requires objects to be built with
-# -fPIC/-fPIE (so set CMAKE_POSITION_INDEPENDENT_CODE to enable that).
-set(CMAKE_POSITION_INDEPENDENT_CODE ON)
-
 # Preprocessor definitions common to all compilers
 set_property(DIRECTORY
 	PROPERTY COMPILE_DEFINITIONS

-- 
2.49.0

